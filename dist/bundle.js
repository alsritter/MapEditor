/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/canvasController.ts":
/*!************************************!*\
  !*** ./src/ts/canvasController.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getMapData\": () => (/* binding */ getMapData),\n/* harmony export */   \"getStartAndEndPos\": () => (/* binding */ getStartAndEndPos),\n/* harmony export */   \"drawCanvas\": () => (/* binding */ drawCanvas)\n/* harmony export */ });\n/* harmony import */ var _view_drawTools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view/drawTools */ \"./src/ts/view/drawTools.ts\");\n/* harmony import */ var _data_gridManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data/gridManager */ \"./src/ts/data/gridManager.ts\");\n/* harmony import */ var _tileController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tileController */ \"./src/ts/tileController.ts\");\n/* harmony import */ var _view_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view/renderer */ \"./src/ts/view/renderer.ts\");\n/* harmony import */ var _data_brushTools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data/brushTools */ \"./src/ts/data/brushTools.ts\");\n/* harmony import */ var _data_enumType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data/enumType */ \"./src/ts/data/enumType.ts\");\n/* harmony import */ var _data_mapStack__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./data/mapStack */ \"./src/ts/data/mapStack.ts\");\n/**\r\n * @file 画布区域的控制器，这个需要等待 tileController 执行完后再执行，\r\n * 所以将这个 Controller 暴露出去让 tileController 执行\r\n *\r\n * @author alsritter(alsritter1@gmail.com)\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// 将这个提取为全局的（核心的地图数据）\r\nvar gridManagerArray = new Array();\r\n// 记录出生点和终点的位置\r\nvar startAndEndPos = new _data_gridManager__WEBPACK_IMPORTED_MODULE_1__.StartAndEndPos(new _data_gridManager__WEBPACK_IMPORTED_MODULE_1__.Grid(0, 0, 0, 0), new _data_gridManager__WEBPACK_IMPORTED_MODULE_1__.Grid(0, 0, 0, 0));\r\n/**\r\n * @returns {GridManager[]} 返回 Map\r\n */\r\nfunction getMapData() {\r\n    return gridManagerArray;\r\n}\r\n/**\r\n * @returns {StartAndEndPos} 返回 出生位置和终点位置\r\n */\r\nfunction getStartAndEndPos() {\r\n    return startAndEndPos;\r\n}\r\nfunction drawCanvas() {\r\n    // 取得画布\r\n    var canvas = document.getElementById('canvas');\r\n    // 取得绘图工具选择\r\n    var toolType = document.getElementById('brushTools');\r\n    // 取得图层\r\n    var layer = document.getElementById('layer');\r\n    // 显示模式\r\n    var showType = document.getElementById('showType');\r\n    // 清空画布\r\n    var cleanButton = document.getElementById('clearCanvas');\r\n    // 设置网格的行列\r\n    var _gridColSize = 50;\r\n    var _gridRowSize = 15;\r\n    // 宽度不变，主要是高度会改变\r\n    var _space = Math.ceil(canvas.width / _gridColSize);\r\n    canvas.height = _space * _gridRowSize;\r\n    var currentTool = _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.DRAW;\r\n    var currentLayer = 0;\r\n    var isShowAll = true;\r\n    // 使用的工具\r\n    toolType.onchange = function () {\r\n        currentTool = _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.returnToolType(toolType.selectedIndex);\r\n    };\r\n    layer.onchange = function () {\r\n        currentLayer = layer.selectedIndex;\r\n    };\r\n    // 这里实例化图层数量个 GridManager\r\n    for (var i = 0; i < layer.options.length; i++) {\r\n        gridManagerArray.push(new _data_gridManager__WEBPACK_IMPORTED_MODULE_1__.GridManager(_space, _gridColSize, _gridRowSize));\r\n    }\r\n    var ctx = canvas.getContext('2d');\r\n    _view_drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawGrid(ctx, _space, canvas.width, _space * _gridRowSize, _gridColSize, _gridRowSize);\r\n    // 临时存储当前选中的格子\r\n    var tempGrid;\r\n    // 标识当前是否按下\r\n    var isDown = false;\r\n    // 记录按下时所在的格子\r\n    var downPosition = { x: 0, y: 0 };\r\n    // 记录绘图前的数据，方便撤回\r\n    var tempMap = new _data_mapStack__WEBPACK_IMPORTED_MODULE_6__.MapStack();\r\n    // 改变了显示模式也需要刷新\r\n    showType.onclick = function (e) {\r\n        if (e.target.tagName == 'INPUT') {\r\n            isShowAll = e.target.value == '0';\r\n            _view_renderer__WEBPACK_IMPORTED_MODULE_3__.RendererTools.refresh(ctx, canvas, _space, _gridRowSize, _gridColSize, gridManagerArray, currentLayer, isShowAll, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), startAndEndPos);\r\n        }\r\n    };\r\n    // 监听清空画布\r\n    cleanButton.onclick = function () {\r\n        // 清空了画布之前需要入栈\r\n        tempMap.push({\r\n            layer: currentLayer,\r\n            map: gridManagerArray[currentLayer].getClone()\r\n        });\r\n        gridManagerArray[currentLayer].cleanMap();\r\n        _view_renderer__WEBPACK_IMPORTED_MODULE_3__.RendererTools.refresh(ctx, canvas, _space, _gridRowSize, _gridColSize, gridManagerArray, currentLayer, isShowAll, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), startAndEndPos);\r\n    };\r\n    // 监听撤回键（使用栈）\r\n    document.onkeydown = function (e) {\r\n        if (e.ctrlKey == true && e.key == 'z') {\r\n            // 如果栈内不为空才撤回\r\n            if (tempMap.size() !== 0) {\r\n                // 弹栈\r\n                var temp = tempMap.pop();\r\n                gridManagerArray[temp.layer].setMap(temp.map);\r\n                _view_renderer__WEBPACK_IMPORTED_MODULE_3__.RendererTools.refresh(ctx, canvas, _space, _gridRowSize, _gridColSize, gridManagerArray, currentLayer, isShowAll, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), startAndEndPos);\r\n            }\r\n        }\r\n    };\r\n    // 鼠标点击绘制\r\n    canvas.onmousedown = function (e) {\r\n        var tempX = Math.floor(e.offsetY / _space);\r\n        var tempY = Math.floor(e.offsetX / _space);\r\n        // 入栈时必须加上当前的 Layer\r\n        tempMap.push({\r\n            layer: currentLayer,\r\n            map: gridManagerArray[currentLayer].getClone()\r\n        });\r\n        isDown = true;\r\n        downPosition.x = tempX;\r\n        downPosition.y = tempY;\r\n        // 如果是空的则无法绘制\r\n        // 因为橡皮擦不显示 Tile，只显示阴影，所以需要单独拿出来\r\n        switch (currentTool) {\r\n            // 单笔刷点击时的绘制\r\n            case _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.DRAW:\r\n                _data_brushTools__WEBPACK_IMPORTED_MODULE_4__.BrushTools.singleDownBrush(gridManagerArray, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), currentLayer, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().x, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().y, tempX, tempY);\r\n                break;\r\n            // 油漆桶\r\n            case _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.FILL:\r\n                _data_brushTools__WEBPACK_IMPORTED_MODULE_4__.BrushTools.fillDownBrush(_gridRowSize, _gridColSize, gridManagerArray, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), currentLayer, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().x, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().y);\r\n                break;\r\n            // 橡皮擦\r\n            case _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.ERASE:\r\n                _data_brushTools__WEBPACK_IMPORTED_MODULE_4__.BrushTools.Erase(gridManagerArray, currentLayer, tempX, tempY);\r\n                break;\r\n            case _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.Start:\r\n                _data_brushTools__WEBPACK_IMPORTED_MODULE_4__.BrushTools.setStartPosition(tempX, tempY, startAndEndPos);\r\n                break;\r\n            case _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.END:\r\n                _data_brushTools__WEBPACK_IMPORTED_MODULE_4__.BrushTools.setEndPosition(tempX, tempY, startAndEndPos);\r\n                break;\r\n        }\r\n        // 因为橡皮擦不显示 Tile，只显示阴影，所以需要单独拿出来\r\n        if (currentTool == _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.ERASE) {\r\n            // 刷新画布\r\n            _view_renderer__WEBPACK_IMPORTED_MODULE_3__.RendererTools.refreshAndShowDark(ctx, canvas, _space, _gridRowSize, _gridColSize, gridManagerArray, currentLayer, isShowAll, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), tempX, tempY, startAndEndPos);\r\n        }\r\n        else {\r\n            // 单笔刷未点击时的绘制\r\n            _view_renderer__WEBPACK_IMPORTED_MODULE_3__.RendererTools.refreshAndShowTile(ctx, canvas, _space, _gridRowSize, _gridColSize, gridManagerArray, currentLayer, isShowAll, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().x, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().y, tempX, tempY, startAndEndPos);\r\n        }\r\n    };\r\n    // 鼠标离开屏幕时\r\n    canvas.onmouseout = function () {\r\n        isDown = false;\r\n    };\r\n    // 鼠标松开时\r\n    canvas.onmouseup = function () {\r\n        isDown = false;\r\n    };\r\n    // 鼠标移动时（核心区域）\r\n    canvas.onmousemove = function (e) {\r\n        var tempX = Math.floor(e.offsetY / _space);\r\n        var tempY = Math.floor(e.offsetX / _space);\r\n        // 如果超出屏幕则直接返回\r\n        if (tempY > _gridColSize - 1 ||\r\n            tempX > _gridRowSize - 1 ||\r\n            tempX < 0 ||\r\n            tempY < 0) {\r\n            return;\r\n        }\r\n        // 只有在不同的格子里才要重绘（否则会在一个格子里面不断的重绘）\r\n        if (tempGrid != gridManagerArray[currentLayer].getGrid(tempX, tempY)) {\r\n            tempGrid = gridManagerArray[currentLayer].getGrid(tempX, tempY);\r\n            // 只有点击了才能使用笔刷\r\n            if (isDown) {\r\n                switch (currentTool) {\r\n                    // 单笔刷点击时的绘制\r\n                    case _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.DRAW:\r\n                        _data_brushTools__WEBPACK_IMPORTED_MODULE_4__.BrushTools.singleDownBrush(gridManagerArray, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), currentLayer, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().x, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().y, tempX, tempY);\r\n                        break;\r\n                    // 如果是选区笔刷\r\n                    case _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.DRAWAREA:\r\n                        _data_brushTools__WEBPACK_IMPORTED_MODULE_4__.BrushTools.areaDownBrush(gridManagerArray, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), currentLayer, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().x, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().y, downPosition.x, downPosition.y, tempX, tempY);\r\n                        break;\r\n                    // 橡皮擦\r\n                    case _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.ERASE:\r\n                        _data_brushTools__WEBPACK_IMPORTED_MODULE_4__.BrushTools.Erase(gridManagerArray, currentLayer, tempX, tempY);\r\n                        break;\r\n                    // 选区橡皮擦\r\n                    case _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.ERASEAREA:\r\n                        _data_brushTools__WEBPACK_IMPORTED_MODULE_4__.BrushTools.areaErase(gridManagerArray, currentLayer, downPosition.x, downPosition.y, tempX, tempY);\r\n                        break;\r\n                }\r\n            }\r\n            // 因为橡皮擦不显示 Tile，只显示阴影，所以需要单独拿出来\r\n            if (currentTool == _data_enumType__WEBPACK_IMPORTED_MODULE_5__.Tool.ERASE) {\r\n                // 刷新画布\r\n                _view_renderer__WEBPACK_IMPORTED_MODULE_3__.RendererTools.refreshAndShowDark(ctx, canvas, _space, _gridRowSize, _gridColSize, gridManagerArray, currentLayer, isShowAll, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), tempX, tempY, startAndEndPos);\r\n            }\r\n            else {\r\n                // 单笔刷未点击时的绘制\r\n                _view_renderer__WEBPACK_IMPORTED_MODULE_3__.RendererTools.refreshAndShowTile(ctx, canvas, _space, _gridRowSize, _gridColSize, gridManagerArray, currentLayer, isShowAll, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileManage)(), (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().x, (0,_tileController__WEBPACK_IMPORTED_MODULE_2__.getTileIndex)().y, tempX, tempY, startAndEndPos);\r\n            }\r\n        }\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MapEditor/./src/ts/canvasController.ts?");

/***/ }),

/***/ "./src/ts/data/TileManager.ts":
/*!************************************!*\
  !*** ./src/ts/data/TileManager.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TileManager\": () => (/* binding */ TileManager)\n/* harmony export */ });\n/**\r\n * @file 保存 Tile 在图中的位置\r\n *\r\n * @author alsritter(alsritter1@gmail.com)\r\n */\r\n/**\r\n * 单个 Tile 在图片的位置\r\n */\r\nvar Tile = /** @class */ (function () {\r\n    /**\r\n     * Tile 在贴图里面的位置，以及保存它的路径偏移量（贴图位置和路径偏移量无关，后者是保存它显示在屏幕的位置）\r\n     * @param {Number} x Tile 在贴图里的起始 x\r\n     * @param {Number} y Tile 在贴图里的起始 y\r\n     * @param {Boolean}} isEmpty 是否是空的\r\n     */\r\n    function Tile(x, y, isEmpty) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.isEmpty = isEmpty;\r\n    }\r\n    return Tile;\r\n}());\r\n/**\r\n * TileImage 里面的 Tile\r\n */\r\nvar TileManager = /** @class */ (function () {\r\n    /**\r\n     * @param {CanvasRenderingContext2D} ctx 传入 canvas 的 Context 用于检测图像是否是空的\r\n     * @param {Number} cols Tile贴图的宽度（一列有多少个 Tile）\r\n     * @param {Number} rows Tile贴图的高度（一行有多少个 Tile）\r\n     * @param {HTMLImageElement} img 这里传入的 Tile 贴图，必须放在 onload 里面执行\r\n     */\r\n    function TileManager(ctx, cols, rows, img) {\r\n        this.cols = cols;\r\n        this.rows = rows;\r\n        this.img = img;\r\n        this.tileMap = [];\r\n        this.sWidth = 0; // 每个单元格的宽度\r\n        this.sHeight = 0; // 每个单元格的高度\r\n        this.sWidth = this.img.width / this.cols; // 切图的宽度\r\n        this.sHeight = this.img.height / this.rows; // 切图的高度\r\n        for (var col = 0; col < this.cols; col++) {\r\n            var temp = [];\r\n            for (var row = 0; row < this.rows; row++) {\r\n                // 还要判断当前的图是否是空的\r\n                var tempX = row * this.sHeight;\r\n                var tempY = col * this.sWidth;\r\n                temp.push(new Tile(tempX, tempY, this.tileIsEmpty(ctx, img, tempX, tempY, this.sWidth)));\r\n            }\r\n            this.tileMap.push(temp);\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx 传入 canvas 的 Context 用于检测图像是否是空的\r\n     * @param {HTMLImageElement} img 这里传入的 Tile 贴图，必须放在 onload 里面执行\r\n     * @param {Number} x 起点x\r\n     * @param {Number} y 起点y\r\n     * @param {Number} space 大小\r\n     * @returns {Boolean} true 表示是空的\r\n     */\r\n    TileManager.prototype.tileIsEmpty = function (ctx, img, x, y, space) {\r\n        // 清除画布\r\n        ctx.clearRect(0, 0, space, space);\r\n        // 图片绘制在画布上\r\n        ctx.drawImage(img, x, y, space, space, 0, 0, space, space);\r\n        // 获取图片像素信息\r\n        var imageData = ctx.getImageData(0, 0, space, space).data;\r\n        // 只要超过 三分之一的内容就表示当前图像不是空的（因为是 RGBA 所以需要除 4）\r\n        var imageLength = Math.floor(Math.floor(imageData.length / 4));\r\n        var temp = 0;\r\n        for (var index = 3; index < imageData.length; index += 4) {\r\n            if (imageData[index] > 0) {\r\n                temp += 1;\r\n            }\r\n        }\r\n        return temp < Math.floor(imageLength / 10);\r\n    };\r\n    /**\r\n     * @param {Number} x Tile 的索引\r\n     * @param {Number} y Tile 的索引\r\n     * @returns {Boolean} 返回 当前位置的格子是否是空的\r\n     */\r\n    TileManager.prototype.isEmpty = function (x, y) {\r\n        return this.tileMap[x][y].isEmpty;\r\n    };\r\n    /**\r\n     * @returns {Number} 返回 cols\r\n     */\r\n    TileManager.prototype.getCols = function () {\r\n        return this.cols;\r\n    };\r\n    /**\r\n     * @returns {Number} 返回 rows\r\n     */\r\n    TileManager.prototype.getRows = function () {\r\n        return this.rows;\r\n    };\r\n    /**\r\n     *\r\n     * @param {Number} x Tile 的索引\r\n     * @param {Number} y Tile 的索引\r\n     * @returns {Tile} 返回 index 执行的 Tile\r\n     */\r\n    TileManager.prototype.getTile = function (x, y) {\r\n        return this.tileMap[x][y];\r\n    };\r\n    /**\r\n     * @returns {HTMLImageElement} 返回 Image\r\n     */\r\n    TileManager.prototype.getImage = function () {\r\n        return this.img;\r\n    };\r\n    /**\r\n     * @returns {Number} 返回 Tile的高度\r\n     */\r\n    TileManager.prototype.getHeight = function () {\r\n        return this.sHeight;\r\n    };\r\n    /**\r\n     * @returns {Number} 返回 Tile的宽度\r\n     */\r\n    TileManager.prototype.getWidth = function () {\r\n        return this.sWidth;\r\n    };\r\n    return TileManager;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://MapEditor/./src/ts/data/TileManager.ts?");

/***/ }),

/***/ "./src/ts/data/brushTools.ts":
/*!***********************************!*\
  !*** ./src/ts/data/brushTools.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BrushTools\": () => (/* binding */ BrushTools)\n/* harmony export */ });\n/**\r\n * @file 笔刷工具，这里主要用来修改数据并调用渲染工具\r\n *\r\n * @author alsritter(alsritter1@gmail.com)\r\n */\r\nvar BrushTools = /** @class */ (function () {\r\n    function BrushTools() {\r\n    }\r\n    /**\r\n     * 设置出生点的位置\r\n     *\r\n     * @param {Number} posX 画布上的方块的索引（注意只是索引，并不是坐标）\r\n     * @param {Number} posY 画布上的方块的索引\r\n     * @param {StartAndEndPos} flag 出生点\r\n     */\r\n    BrushTools.setStartPosition = function (posX, posY, flag) {\r\n        flag.start.x = posX;\r\n        flag.start.y = posY;\r\n    };\r\n    /**\r\n     * 设置终点的位置\r\n     *\r\n     * @param {Number} posX 画布上的方块的索引\r\n     * @param {Number} posY 画布上的方块的索引\r\n     * @param {StartAndEndPos} flag 结束点\r\n     */\r\n    BrushTools.setEndPosition = function (posX, posY, flag) {\r\n        flag.end.x = posX;\r\n        flag.end.y = posY;\r\n    };\r\n    /**\r\n     * 鼠标在画布上拖动时（点击时）实时刷新页面，单笔刷\r\n     * 还需要把数据存起来\r\n     *\r\n     * @param {GridManager[]} gridManagerArray\r\n     * @param {TileManager} tileManager 用于判断当前是否是空的\r\n     * @param {Number} layer 当前选中的图层\r\n     * @param {Number} tileX Tile 的索引\r\n     * @param {Number} tileY Tile 的索引\r\n     * @param {Number} posX 画布上的方块的索引\r\n     * @param {Number} posY 画布上的方块的索引\r\n     */\r\n    BrushTools.singleDownBrush = function (gridManagerArray, tileManager, layer, tileX, tileY, posX, posY) {\r\n        if (tileManager.isEmpty(tileX, tileY))\r\n            return;\r\n        // 将当前选中的格子存储起来\r\n        gridManagerArray[layer].getGrid(posX, posY).tileX = tileX;\r\n        gridManagerArray[layer].getGrid(posX, posY).tileY = tileY;\r\n    };\r\n    /**\r\n     * 鼠标在画布上拖动时（点击时）实时刷新页面，选区刷还需\r\n     * 要把数据存起来，这里需要加个判断，如果起点大于终点的\r\n     * 位置则不刷新的格子\r\n     *\r\n     * @param {GridManager[]} gridManagerArray\r\n     * @param {TileManager} tileManager 用于判断当前是否是空的\r\n     * @param {Number} layer 当前选中的图层\r\n     * @param {Number} tileX Tile 的索引\r\n     * @param {Number} tileY Tile 的索引\r\n     * @param {Number} startPosX 画布上的方块的起点索引\r\n     * @param {Number} startPosY 画布上的方块的起点索引\r\n     * @param {Number} endPosX 画布上的方块的当前索引\r\n     * @param {Number} endPosy 画布上的方块的当前索引\r\n     */\r\n    BrushTools.areaDownBrush = function (gridManagerArray, tileManager, layer, tileX, tileY, startPosX, startPosY, endPosX, endPosY) {\r\n        if (tileManager.isEmpty(tileX, tileY))\r\n            return;\r\n        var maxPosX;\r\n        var minPosX;\r\n        var maxPosY;\r\n        var minPosY;\r\n        if (startPosX > endPosX) {\r\n            maxPosX = startPosX;\r\n            minPosX = endPosX;\r\n        }\r\n        else {\r\n            maxPosX = endPosX;\r\n            minPosX = startPosX;\r\n        }\r\n        if (startPosY > endPosY) {\r\n            maxPosY = startPosY;\r\n            minPosY = endPosY;\r\n        }\r\n        else {\r\n            maxPosY = endPosY;\r\n            minPosY = startPosY;\r\n        }\r\n        // 将当前选中的格子存储起来\r\n        for (var i = minPosX; i <= maxPosX; i++) {\r\n            for (var j = minPosY; j <= maxPosY; j++) {\r\n                gridManagerArray[layer].getGrid(i, j).tileX = tileX;\r\n                gridManagerArray[layer].getGrid(i, j).tileY = tileY;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * 填充当前画布\r\n     *\r\n     * @param {Number} rows\r\n     * @param {Number} cols\r\n     * @param {GridManager[]} gridManagerArray\r\n     * @param {TileManager} tileManager 用于判断当前是否是空的\r\n     * @param {Number} layer 当前选中的图层\r\n     * @param {Number} tileX Tile 的索引\r\n     * @param {Number} tileY Tile 的索引\r\n     */\r\n    BrushTools.fillDownBrush = function (rows, cols, gridManagerArray, tileManager, layer, tileX, tileY) {\r\n        if (tileManager.isEmpty(tileX, tileY))\r\n            return;\r\n        // 将当前选中的格子存储起来\r\n        for (var i = 0; i < rows; i++) {\r\n            for (var j = 0; j < cols; j++) {\r\n                gridManagerArray[layer].getGrid(i, j).tileX = tileX;\r\n                gridManagerArray[layer].getGrid(i, j).tileY = tileY;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * 将当前选中的格子设置为 null\r\n     *\r\n     * @param {GridManager[]} gridManagerArray\r\n     * @param {Number} layer 当前选中的图层\r\n     * @param {Number} posX 画布上的方块的索引\r\n     * @param {Number} posY 画布上的方块的索引\r\n     */\r\n    BrushTools.Erase = function (gridManagerArray, layer, posX, posY) {\r\n        gridManagerArray[layer].getGrid(posX, posY).tileX = null;\r\n        gridManagerArray[layer].getGrid(posX, posY).tileY = null;\r\n    };\r\n    /**\r\n     * 将当前选中的区域设置为 null\r\n     *\r\n     * @param {GridManager[]} gridManagerArray\r\n     * @param {Number} layer 当前选中的图层\r\n     * @param {Number} startPosX 画布上的方块的起点索引\r\n     * @param {Number} startPosY 画布上的方块的起点索引\r\n     * @param {Number} endPosX 画布上的方块的当前索引\r\n     * @param {Number} endPosy 画布上的方块的当前索引\r\n     */\r\n    BrushTools.areaErase = function (gridManagerArray, layer, startPosX, startPosY, endPosX, endPosY) {\r\n        var maxPosX;\r\n        var minPosX;\r\n        var maxPosY;\r\n        var minPosY;\r\n        if (startPosX > endPosX) {\r\n            maxPosX = startPosX;\r\n            minPosX = endPosX;\r\n        }\r\n        else {\r\n            maxPosX = endPosX;\r\n            minPosX = startPosX;\r\n        }\r\n        if (startPosY > endPosY) {\r\n            maxPosY = startPosY;\r\n            minPosY = endPosY;\r\n        }\r\n        else {\r\n            maxPosY = endPosY;\r\n            minPosY = startPosY;\r\n        }\r\n        // 将当前选中的格子存储起来\r\n        for (var i = minPosX; i <= maxPosX; i++) {\r\n            for (var j = minPosY; j <= maxPosY; j++) {\r\n                gridManagerArray[layer].getGrid(i, j).tileX = null;\r\n                gridManagerArray[layer].getGrid(i, j).tileY = null;\r\n            }\r\n        }\r\n    };\r\n    return BrushTools;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://MapEditor/./src/ts/data/brushTools.ts?");

/***/ }),

/***/ "./src/ts/data/enumType.ts":
/*!*********************************!*\
  !*** ./src/ts/data/enumType.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tool\": () => (/* binding */ Tool)\n/* harmony export */ });\n/**\r\n * @file 存放常用的枚举类型（利用属性模拟枚举）\r\n *\r\n * @author alsritter(alsritter1@gmail.com)\r\n */\r\n/**\r\n * 这里主要是标识所用的工具\r\n */\r\nvar Tool = /** @class */ (function () {\r\n    function Tool() {\r\n    }\r\n    Object.defineProperty(Tool, \"DRAW\", {\r\n        /**\r\n         * 单笔刷\r\n         */\r\n        get: function () {\r\n            return 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tool, \"DRAWAREA\", {\r\n        /**\r\n         * 选区刷\r\n         */\r\n        get: function () {\r\n            return 1;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tool, \"FILL\", {\r\n        /**\r\n         * 油漆桶\r\n         */\r\n        get: function () {\r\n            return 2;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tool, \"ERASE\", {\r\n        /**\r\n         * 橡皮擦\r\n         */\r\n        get: function () {\r\n            return 3;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tool, \"ERASEAREA\", {\r\n        /**\r\n         * 选区擦\r\n         */\r\n        get: function () {\r\n            return 4;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tool, \"Start\", {\r\n        /**\r\n         * 出生点\r\n         */\r\n        get: function () {\r\n            return 5;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tool, \"END\", {\r\n        /**\r\n         * 终点\r\n         */\r\n        get: function () {\r\n            return 6;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * 返回当前选中的工具类型\r\n     * @param {Number} index 索引\r\n     */\r\n    Tool.returnToolType = function (index) {\r\n        switch (index) {\r\n            case 0:\r\n                return Tool.DRAW;\r\n            case 1:\r\n                return Tool.DRAWAREA;\r\n            case 2:\r\n                return Tool.FILL;\r\n            case 3:\r\n                return Tool.ERASE;\r\n            case 4:\r\n                return Tool.ERASEAREA;\r\n            case 5:\r\n                return Tool.Start;\r\n            case 6:\r\n                return Tool.END;\r\n            default:\r\n                return Tool.DRAW;\r\n        }\r\n    };\r\n    return Tool;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://MapEditor/./src/ts/data/enumType.ts?");

/***/ }),

/***/ "./src/ts/data/gridManager.ts":
/*!************************************!*\
  !*** ./src/ts/data/gridManager.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Grid\": () => (/* binding */ Grid),\n/* harmony export */   \"StartAndEndPos\": () => (/* binding */ StartAndEndPos),\n/* harmony export */   \"GridManager\": () => (/* binding */ GridManager)\n/* harmony export */ });\n/**\r\n * @file 存放格子的位置数据\r\n *\r\n * @author alsritter(alsritter1@gmail.com)\r\n */\r\nvar Grid = /** @class */ (function () {\r\n    /**\r\n     * 存储一个格子的位置（左上角）\r\n     * @param {Number} x 当前格子在 Map里面的x轴坐标\r\n     * @param {Number} y 当前格子在 Map里面的y轴坐标\r\n     * @param {Number | null} tileX 这个格子对应的 Tile索引\r\n     * @param {Number | null} tileY 这个格子对应的 Tile索引\r\n     */\r\n    function Grid(x, y, tileX, tileY) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.tileX = tileX;\r\n        this.tileY = tileY;\r\n    }\r\n    return Grid;\r\n}());\r\n\r\n/**\r\n * 出生和结束的位置\r\n */\r\nvar StartAndEndPos = /** @class */ (function () {\r\n    function StartAndEndPos(start, end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n    return StartAndEndPos;\r\n}());\r\n\r\n// 存储的 Map 示意图\r\n// let map = [\r\n//   [ 0,  4,  8,  4,  8, 12],\r\n//   [ 1,  5,  9,  5,  9, 13],\r\n//   [13,  6, 10,  6, 10, 14],\r\n//   [ 2,  5,  9,  5,  9, 14],\r\n//   [13,  6, 10,  6, 10, 13],\r\n//   [ 3,  7, 11,  4,  8, 15]\r\n// ];\r\nvar GridManager = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param {Number} space 一个格子的大小\r\n     * @param {Number} cols 一行有多少个格子\r\n     * @param {Number} rows 一列一多少个格子\r\n     */\r\n    function GridManager(space, cols, rows) {\r\n        // 先初始化 Map\r\n        this.map = new Array();\r\n        this.cols = cols;\r\n        this.rows = rows;\r\n        for (var i = 0; i < rows; i++) {\r\n            var temp = [];\r\n            for (var j = 0; j < cols; j++) {\r\n                // 初始化先赋值为 null\r\n                temp.push(new Grid(j * space, i * space, null, null));\r\n            }\r\n            this.map.push(temp);\r\n        }\r\n    }\r\n    /**\r\n     * 获取 Grid\r\n     *\r\n     * @param {Number} x 一行的第几个格子\r\n     * @param {Number} y 一列的第几个格子\r\n     * @returns {Grid} 返回 Grid\r\n     */\r\n    GridManager.prototype.getGrid = function (x, y) {\r\n        return this.map[x][y];\r\n    };\r\n    /**\r\n     * @returns {Number} 返回 Cols\r\n     */\r\n    GridManager.prototype.getColNum = function () {\r\n        return this.cols;\r\n    };\r\n    /**\r\n     * @returns {Number} 返回 Rows\r\n     */\r\n    GridManager.prototype.getRowNum = function () {\r\n        return this.rows;\r\n    };\r\n    /**\r\n     * 深拷贝数据\r\n     * @returns {Grid[][]} 返回克隆的 Map\r\n     */\r\n    GridManager.prototype.getClone = function () {\r\n        return JSON.parse(JSON.stringify(this.map));\r\n    };\r\n    /**\r\n     * 修改当前的 Map\r\n     * @param {Grid[][]} newMap\r\n     */\r\n    GridManager.prototype.setMap = function (newMap) {\r\n        this.map = newMap;\r\n    };\r\n    /**\r\n     * 清空当前画布\r\n     */\r\n    GridManager.prototype.cleanMap = function () {\r\n        for (var i = 0; i < this.map.length; i++) {\r\n            for (var j = 0; j < this.map[i].length; j++) {\r\n                this.map[i][j].tileX = null;\r\n                this.map[i][j].tileY = null;\r\n            }\r\n        }\r\n    };\r\n    return GridManager;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://MapEditor/./src/ts/data/gridManager.ts?");

/***/ }),

/***/ "./src/ts/data/mapStack.ts":
/*!*********************************!*\
  !*** ./src/ts/data/mapStack.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MapStack\": () => (/* binding */ MapStack)\n/* harmony export */ });\n/**\r\n * @file 因为 js好像没有栈这种数据结构，所以这里手动实现一个\r\n * 用于撤回操作（先进后出）\r\n *\r\n * @author alsritter(alsritter1@gmail.com)\r\n */\r\n/**\r\n * 自定义的栈结构，主要用来维护 画布数据\r\n */\r\nvar MapStack = /** @class */ (function () {\r\n    function MapStack() {\r\n        this.arr = [];\r\n    }\r\n    /**\r\n     * 压栈操作\r\n     * @param { { layer: number, map: Grid[][] }} mapInfo\r\n     */\r\n    MapStack.prototype.push = function (mapInfo) {\r\n        this.arr.push(mapInfo);\r\n    };\r\n    /**\r\n     * 退栈操作\r\n     */\r\n    MapStack.prototype.pop = function () {\r\n        return this.arr.pop();\r\n    };\r\n    /**\r\n     * 获取栈顶元素\r\n     */\r\n    MapStack.prototype.top = function () {\r\n        return this.arr[this.arr.length - 1];\r\n    };\r\n    /**\r\n     * 获取栈长\r\n     */\r\n    MapStack.prototype.size = function () {\r\n        return this.arr.length;\r\n    };\r\n    /**\r\n     * 清空栈\r\n     */\r\n    MapStack.prototype.clear = function () {\r\n        this.arr = [];\r\n        return true;\r\n    };\r\n    MapStack.prototype.toString = function () {\r\n        return this.arr.toString();\r\n    };\r\n    return MapStack;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://MapEditor/./src/ts/data/mapStack.ts?");

/***/ }),

/***/ "./src/ts/exportMapData.ts":
/*!*********************************!*\
  !*** ./src/ts/exportMapData.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"exportData\": () => (/* binding */ exportData)\n/* harmony export */ });\n/* harmony import */ var _canvasController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvasController */ \"./src/ts/canvasController.ts\");\n\r\nvar Pos = /** @class */ (function () {\r\n    function Pos(tileX, tileY) {\r\n        this.tileX = tileX;\r\n        this.tileY = tileY;\r\n    }\r\n    return Pos;\r\n}());\r\n/**\r\n * 输出的结构应该是由全部所使用到的图块数据，以及下面几层都是引用这个图块的索引\r\n */\r\nfunction exportData() {\r\n    var exportButton = document.getElementById('exportData');\r\n    exportButton.onclick = function () {\r\n        var maps = (0,_canvasController__WEBPACK_IMPORTED_MODULE_0__.getMapData)();\r\n        var layerData = [];\r\n        // 存储用到了哪些图块，方便 Unity 一开始就生成好对应的 Sprite\r\n        // TODO: 注意！！第一个格子是空子，Unity 读取它的时候需要忽略第一个格子\r\n        var spritePos = [new Pos(0, 0)]; // 默认创建一个\r\n        // 第一层遍历是取得各个图层的数据\r\n        for (var i = 0; i < maps.length; i++) {\r\n            var tempMap = maps[i].getClone();\r\n            var y_map = [];\r\n            // 这里两层 for 是遍历 Map 取得数据\r\n            for (var j = 0; j < tempMap.length; j++) {\r\n                var x_map = [];\r\n                for (var k = 0; k < tempMap[j].length; k++) {\r\n                    tempMap[j][k].tileX =\r\n                        tempMap[j][k].tileX == null ? 0 : tempMap[j][k].tileX;\r\n                    tempMap[j][k].tileY =\r\n                        tempMap[j][k].tileY == null ? 0 : tempMap[j][k].tileY;\r\n                    // 标识图块索引\r\n                    var p_temp = 0;\r\n                    var isExist = false; //标识是否存在\r\n                    // 判断当前是否存在这个 spritePos 存在则直接返回这个索引，否则先创建了再返回索引\r\n                    for (var p = 0; p < spritePos.length; p++) {\r\n                        if (spritePos[p].tileX == tempMap[j][k].tileX &&\r\n                            spritePos[p].tileY == tempMap[j][k].tileY) {\r\n                            p_temp = p;\r\n                            isExist = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!isExist) {\r\n                        spritePos.push(new Pos(tempMap[j][k].tileX, tempMap[j][k].tileY));\r\n                        p_temp = spritePos.length - 1; // 数组长度减一表示最后一个\r\n                        isExist = false; // 重置\r\n                    }\r\n                    x_map.push(p_temp);\r\n                }\r\n                y_map.push(x_map);\r\n            }\r\n            layerData.push(y_map);\r\n        }\r\n        var data = {\r\n            start: {\r\n                x: (0,_canvasController__WEBPACK_IMPORTED_MODULE_0__.getStartAndEndPos)().start.x,\r\n                y: (0,_canvasController__WEBPACK_IMPORTED_MODULE_0__.getStartAndEndPos)().start.y\r\n            },\r\n            end: {\r\n                x: (0,_canvasController__WEBPACK_IMPORTED_MODULE_0__.getStartAndEndPos)().end.x,\r\n                y: (0,_canvasController__WEBPACK_IMPORTED_MODULE_0__.getStartAndEndPos)().end.y\r\n            },\r\n            sprites: spritePos,\r\n            background: layerData[0],\r\n            collision: layerData[1],\r\n            traps: layerData[2],\r\n            foreground: layerData[3]\r\n        };\r\n        console.log(data);\r\n        var content = JSON.stringify(data);\r\n        var eleLink = document.createElement('a');\r\n        eleLink.download = 'mapData.json';\r\n        eleLink.style.display = 'none';\r\n        // 字符内容转变成blob地址\r\n        var blob = new Blob([content]);\r\n        eleLink.href = URL.createObjectURL(blob);\r\n        // 触发点击\r\n        document.body.appendChild(eleLink);\r\n        eleLink.click();\r\n        // 然后移除\r\n        document.body.removeChild(eleLink);\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://MapEditor/./src/ts/exportMapData.ts?");

/***/ }),

/***/ "./src/ts/tileController.ts":
/*!**********************************!*\
  !*** ./src/ts/tileController.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getTileIndex\": () => (/* binding */ getTileIndex),\n/* harmony export */   \"getTileManage\": () => (/* binding */ getTileManage)\n/* harmony export */ });\n/* harmony import */ var _view_drawTools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view/drawTools */ \"./src/ts/view/drawTools.ts\");\n/* harmony import */ var _data_gridManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data/gridManager */ \"./src/ts/data/gridManager.ts\");\n/* harmony import */ var _data_TileManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./data/TileManager */ \"./src/ts/data/TileManager.ts\");\n/* harmony import */ var _canvasController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./canvasController */ \"./src/ts/canvasController.ts\");\n/* harmony import */ var _exportMapData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./exportMapData */ \"./src/ts/exportMapData.ts\");\n/**\r\n * @file 取色器区域的控制器\r\n *\r\n * @author alsritter(alsritter1@gmail.com)\r\n */\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Tile 的索引\r\n */\r\nvar TileIndex = /** @class */ (function () {\r\n    function TileIndex() {\r\n        this.x = 0;\r\n        this.y = 0;\r\n    }\r\n    return TileIndex;\r\n}());\r\nvar _tileIndex = new TileIndex();\r\nvar _tileManager; // 需要把这个传递出去，所以这里需要提升到全局\r\nfunction drawTiles() {\r\n    // 先绘制网格\r\n    var canvas = document.getElementById('tileCanvas');\r\n    var img = new Image();\r\n    img.onload = function () {\r\n        canvas.width = img.width;\r\n        canvas.height = img.height;\r\n        var _cols = 16;\r\n        var _rows = 16;\r\n        // 先获取每个图形格子的大小\r\n        var _space = img.width / _cols;\r\n        var ctx = canvas.getContext('2d');\r\n        var gridManager = new _data_gridManager__WEBPACK_IMPORTED_MODULE_1__.GridManager(_space, _cols, _rows);\r\n        _tileManager = new _data_TileManager__WEBPACK_IMPORTED_MODULE_2__.TileManager(ctx, _cols, _rows, img);\r\n        _view_drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawBackground(ctx, canvas.width, canvas.height);\r\n        _view_drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawAllTile(ctx, _tileManager, gridManager, _space);\r\n        // 根据鼠标点击取得格子\r\n        canvas.onmousedown = function (e) {\r\n            var temp = gridManager.getGrid(Math.floor(e.offsetY / _space), Math.floor(e.offsetX / _space));\r\n            _view_drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawDark(ctx, _space, temp.x, temp.y);\r\n            // 修改下当前选中的 Tile的索引\r\n            _tileIndex.x = Math.floor(e.offsetY / _space);\r\n            _tileIndex.y = Math.floor(e.offsetX / _space);\r\n        };\r\n        canvas.onmouseup = function () {\r\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n            _view_drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawBackground(ctx, canvas.width, canvas.height);\r\n            _view_drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawAllTile(ctx, _tileManager, gridManager, _space);\r\n        };\r\n        // 等待取色器执行完成再执行这块\r\n        (0,_canvasController__WEBPACK_IMPORTED_MODULE_3__.drawCanvas)();\r\n        // 等待上面的画布加载完成才能导出数据\r\n        (0,_exportMapData__WEBPACK_IMPORTED_MODULE_4__.exportData)();\r\n    };\r\n    img.src = './src/img/tiles.png';\r\n}\r\nwindow.addEventListener('load', drawTiles, false);\r\n/**\r\n * 用来传递当前取色器取到的格子给下面的画布\r\n *\r\n * @returns {TileIndex} 返回 TileIndex\r\n */\r\nfunction getTileIndex() {\r\n    return _tileIndex;\r\n}\r\n/**\r\n * 用来传递当前的TileManager\r\n *\r\n * @returns {TileManager} 返回 TileManager\r\n */\r\nfunction getTileManage() {\r\n    return _tileManager;\r\n}\r\n\n\n//# sourceURL=webpack://MapEditor/./src/ts/tileController.ts?");

/***/ }),

/***/ "./src/ts/view/drawTools.ts":
/*!**********************************!*\
  !*** ./src/ts/view/drawTools.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawTools\": () => (/* binding */ DrawTools)\n/* harmony export */ });\n/**\r\n * @file 存放绘制工具\r\n *\r\n * @author alsritter(alsritter1@gmail.com)\r\n */\r\nvar DrawTools = /** @class */ (function () {\r\n    function DrawTools() {\r\n    }\r\n    /**\r\n     * 绘制网格\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx 传入 canvas 的 Context\r\n     * @param {Number} space 一个格子的大小\r\n     * @param {Number} width 画布的宽度\r\n     * @param {Number} height 画布的高度\r\n     * @param {Number} gridWithSize 一行多少个格子\r\n     * @param {Number} gridHeightSize 一列有多少个格子\r\n     */\r\n    DrawTools.drawGrid = function (ctx, space, width, height, gridWithSize, gridHeightSize) {\r\n        // 采用遍历的方式，绘画x轴的线条\r\n        for (var i = 0; i < gridWithSize; i++) {\r\n            ctx.beginPath(); // 开启路径，设置不同的样式\r\n            ctx.moveTo(space * i - 0.5, 0); // -0.5是为了解决像素模糊问题\r\n            ctx.lineTo(space * i - 0.5, height);\r\n            ctx.setLineDash([1, 2]); //绘制虚线\r\n            ctx.strokeStyle = '#2a2a2a'; // 设置每个线条的颜色\r\n            ctx.stroke();\r\n        }\r\n        // 同理y轴\r\n        for (var i = 0; i < gridHeightSize; i++) {\r\n            ctx.beginPath(); // 开启路径，设置不同的样式\r\n            ctx.moveTo(0, space * i - 0.5);\r\n            ctx.lineTo(width, space * i - 0.5);\r\n            ctx.strokeStyle = '#2a2a2a';\r\n            ctx.stroke();\r\n        }\r\n    };\r\n    /**\r\n     * 让指定的位置变暗\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx 传入 canvas 的 Context\r\n     * @param {Number} space 一个格子的大小\r\n     * @param {Number} x 绘制目的地的 x\r\n     * @param {Number} y 绘制目的地的 y\r\n     */\r\n    DrawTools.drawDark = function (ctx, space, x, y) {\r\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\r\n        ctx.beginPath();\r\n        ctx.rect(x, y, space, space);\r\n        ctx.fill();\r\n        ctx.closePath();\r\n    };\r\n    /**\r\n     * 让指定的位置变成指定的颜色\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx 传入 canvas 的 Context\r\n     * @param {Number} space 一个格子的大小\r\n     * @param {Number} x 绘制目的地的 x\r\n     * @param {Number} y 绘制目的地的 y\r\n     * @param {String} color 指定的颜色\r\n     */\r\n    DrawTools.drawColor = function (ctx, space, x, y, color) {\r\n        ctx.fillStyle = color;\r\n        ctx.beginPath();\r\n        ctx.rect(x, y, space, space);\r\n        ctx.fill();\r\n        ctx.closePath();\r\n    };\r\n    /**\r\n     * 在指定位置绘制一个 Tile 注意这个 X Y 是以这个 ctx 为原点的\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx 传入 canvas 的 Context\r\n     * @param {TileManager} map 传入 TileManager\r\n     * @param {Number} tileX Tile 的索引\r\n     * @param {Number} tileY Tile 的索引\r\n     * @param {Number} space 一个格子的大小\r\n     * @param {Number} x 绘制目的地的 x\r\n     * @param {Number} y 绘制目的地的 y\r\n     */\r\n    DrawTools.drawTile = function (ctx, map, tileX, tileY, space, x, y) {\r\n        ctx.drawImage(map.getImage(), map.getTile(tileX, tileY).x, map.getTile(tileX, tileY).y, map.getWidth(), map.getHeight(), x, y, space, space);\r\n    };\r\n    /**\r\n     * 绘制背景方格\r\n     * @param {CanvasRenderingContext2D} ctx 传入 canvas 的 Context\r\n     * @param {Number} width 画布的宽度\r\n     * @param {Number} height 画布的高度\r\n     */\r\n    DrawTools.drawBackground = function (ctx, width, height) {\r\n        var emptyBox = ctx.createImageData(width, height);\r\n        var emptyBoxData = emptyBox.data;\r\n        // 通过 canvas宽高 来遍历一下 canvas 上的所有像素点\r\n        for (var i = 0; i < height; i++) {\r\n            for (var j = 0; j < width; j++) {\r\n                var point = (i * width + j) << 2; // << 相当于 * 4\r\n                var rgbData = ((i >> 2) + (j >> 2)) & ( true ? 1 : 0) ? 204 : 255; // >> 2 相当于 / 4 取整， & 1相当于 % 2\r\n                emptyBoxData[point] = rgbData;\r\n                emptyBoxData[point + 1] = rgbData;\r\n                emptyBoxData[point + 2] = rgbData;\r\n                emptyBoxData[point + 3] = 255;\r\n            }\r\n        }\r\n        ctx.putImageData(emptyBox, 0, 0);\r\n    };\r\n    /**\r\n     * 绘制 pos 里面存储的 Tile\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx 传入 canvas 的 Context\r\n     * @param {TileManager} map 传入 TileManager\r\n     * @param {GridManager} pos 传入 位置列表\r\n     * @param {Number} space 一个格子的大小\r\n     */\r\n    DrawTools.drawMapTile = function (ctx, map, pos, space) {\r\n        for (var i = 0; i < pos.getRowNum(); i++) {\r\n            for (var j = 0; j < pos.getColNum(); j++) {\r\n                // 如果还是 null 或者为空的则直接跳过\r\n                if (pos.getGrid(i, j).tileX != null &&\r\n                    pos.getGrid(i, j).tileY != null &&\r\n                    !DrawTools.isEmpty(map, pos.getGrid(i, j).tileX, pos.getGrid(i, j).tileY) // 这个判断得放在后面\r\n                ) {\r\n                    DrawTools.drawTile(ctx, map, pos.getGrid(i, j).tileX, pos.getGrid(i, j).tileY, space, pos.getGrid(i, j).x, pos.getGrid(i, j).y);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * 判度当前位置上的图片是否是空的\r\n     * @param {TileManager} map\r\n     * @param {Number} tileX\r\n     * @param {Number} tileY\r\n     * @returns {Boolean} true 表示是空的\r\n     */\r\n    DrawTools.isEmpty = function (map, tileX, tileY) {\r\n        return map.getTile(tileX, tileY).isEmpty;\r\n    };\r\n    /**\r\n     * 绘制 Map里面的全部 Tile\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx 传入 canvas 的 Context\r\n     * @param {TileManager} map 传入 TileManager\r\n     * @param {GridManager} pos 传入 位置列表\r\n     * @param {Number} space 一个格子的大小\r\n     */\r\n    DrawTools.drawAllTile = function (ctx, map, pos, space) {\r\n        for (var i = 0; i < map.getCols(); i++) {\r\n            for (var j = 0; j < map.getRows(); j++) {\r\n                DrawTools.drawTile(ctx, map, i, j, space, pos.getGrid(i, j).x, pos.getGrid(i, j).y);\r\n            }\r\n        }\r\n    };\r\n    return DrawTools;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://MapEditor/./src/ts/view/drawTools.ts?");

/***/ }),

/***/ "./src/ts/view/renderer.ts":
/*!*********************************!*\
  !*** ./src/ts/view/renderer.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RendererTools\": () => (/* binding */ RendererTools)\n/* harmony export */ });\n/* harmony import */ var _drawTools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./drawTools */ \"./src/ts/view/drawTools.ts\");\n/**\r\n * @file 渲染绘制，这里只负责渲染数据，不负责刷新数据\r\n *\r\n * @author alsritter(alsritter1@gmail.com)\r\n */\r\n\r\nvar RendererTools = /** @class */ (function () {\r\n    function RendererTools() {\r\n    }\r\n    /**\r\n     * 绘制起点和终点\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {Number} space\r\n     * @param {Number} b_x\r\n     * @param {Number} b_y\r\n     * @param {Number} e_x\r\n     * @param {Number} e_y\r\n     */\r\n    RendererTools.drawStartAndEnd = function (ctx, space, b_x, b_y, e_x, e_y) {\r\n        // 绘制起点\r\n        _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawColor(ctx, space, b_x, b_y, 'rgba(238, 49, 49, 0.5)');\r\n        // 绘制终点\r\n        _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawColor(ctx, space, e_x, e_y, 'rgba(0, 122, 204, 0.5)');\r\n    };\r\n    /**\r\n     * 基本修改了页面数据都需要调用这个刷新（不绘制选中的 Tile）\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {HTMLElement} canvas\r\n     * @param {Number} space\r\n     * @param {Number} rows\r\n     * @param {Number} cols\r\n     * @param {GridManager[]} gridManagerArray\r\n     * @param {Number} layer 当前选中的图层\r\n     * @param {Boolean} showAll 是否显示全部图层，true 表示是\r\n     * @param {TileManager} tileManager\r\n     * @param {StartAndEndPos} flag 起点和终点的位置\r\n     */\r\n    RendererTools.refresh = function (ctx, canvas, space, rows, cols, gridManagerArray, layer, showAll, tileManager, flag) {\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawGrid(ctx, space, canvas.width, space * rows, cols, rows);\r\n        // 如果显示全部图层则，遍历刷新\r\n        if (showAll) {\r\n            for (var i = 0; i < gridManagerArray.length; i++) {\r\n                // 绘制 Map 里面已有的 Tile\r\n                _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawMapTile(ctx, tileManager, gridManagerArray[i], space);\r\n            }\r\n        }\r\n        else {\r\n            // 绘制 Map 里面已有的 Tile\r\n            _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawMapTile(ctx, tileManager, gridManagerArray[layer], space);\r\n        }\r\n        RendererTools.drawStartAndEnd(ctx, space, gridManagerArray[0].getGrid(flag.start.x, flag.start.y).x, gridManagerArray[0].getGrid(flag.start.x, flag.start.y).y, gridManagerArray[0].getGrid(flag.end.x, flag.end.y).x, gridManagerArray[0].getGrid(flag.end.x, flag.end.y).y);\r\n    };\r\n    /**\r\n     * 作用同上，但是会绘制选中的 Tile\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {HTMLCanvasElement} canvas\r\n     * @param {Number} space\r\n     * @param {Number} rows\r\n     * @param {Number} cols\r\n     * @param {GridManager[]} gridManagerArray\r\n     * @param {Layer} layer 当前选中的图层\r\n     * @param {Boolean} showAll 是否显示全部图层，true 表示是\r\n     * @param {TileManager} tileManager\r\n     * @param {Number} tileX Tile 的索引\r\n     * @param {Number} tileY Tile 的索引\r\n     * @param {Number} posX 画布上的方块的索引\r\n     * @param {Number} posY 画布上的方块的索引\r\n     * @param {StartAndEndPos} flag 起点和终点的位置\r\n     */\r\n    RendererTools.refreshAndShowTile = function (ctx, canvas, space, rows, cols, gridManagerArray, layer, showAll, tileManager, tileX, tileY, posX, posY, flag) {\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawGrid(ctx, space, canvas.width, space * rows, cols, rows);\r\n        // 如果显示全部图层则，遍历刷新\r\n        if (showAll) {\r\n            for (var i = 0; i < gridManagerArray.length; i++) {\r\n                // 绘制 Map 里面已有的 Tile\r\n                _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawMapTile(ctx, tileManager, gridManagerArray[i], space);\r\n            }\r\n        }\r\n        else {\r\n            // 绘制 Map 里面已有的 Tile\r\n            _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawMapTile(ctx, tileManager, gridManagerArray[layer], space);\r\n        }\r\n        // 显示当前选中的 Tile\r\n        _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawTile(ctx, tileManager, tileX, tileY, space, gridManagerArray[layer].getGrid(posX, posY).x, gridManagerArray[layer].getGrid(posX, posY).y);\r\n        RendererTools.drawStartAndEnd(ctx, space, gridManagerArray[0].getGrid(flag.start.x, flag.start.y).x, gridManagerArray[0].getGrid(flag.start.x, flag.start.y).y, gridManagerArray[0].getGrid(flag.end.x, flag.end.y).x, gridManagerArray[0].getGrid(flag.end.x, flag.end.y).y);\r\n        // 绘制阴影\r\n        _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawDark(ctx, space, gridManagerArray[layer].getGrid(posX, posY).x, gridManagerArray[layer].getGrid(posX, posY).y);\r\n    };\r\n    /**\r\n     * 作用同上，但是只绘制阴影\r\n     *\r\n     * @param {CanvasRenderingContext2D} ctx\r\n     * @param {HTMLCanvasElement} canvas\r\n     * @param {Number} space\r\n     * @param {Number} rows\r\n     * @param {Number} cols\r\n     * @param {GridManager[]} gridManagerArray\r\n     * @param {Layer} layer 当前选中的图层\r\n     * @param {Boolean} showAll 是否显示全部图层，true 表示是\r\n     * @param {TileManager} tileManager\r\n     * @param {Number} tileX Tile 的索引\r\n     * @param {Number} tileY Tile 的索引\r\n     * @param {Number} posX 画布上的方块的索引\r\n     * @param {Number} posY 画布上的方块的索引\r\n     * @param {StartAndEndPos} flag 起点和终点的位置\r\n     */\r\n    RendererTools.refreshAndShowDark = function (ctx, canvas, space, rows, cols, gridManagerArray, layer, showAll, tileManager, posX, posY, flag) {\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawGrid(ctx, space, canvas.width, space * rows, cols, rows);\r\n        // 如果显示全部图层则，遍历刷新\r\n        if (showAll) {\r\n            for (var i = 0; i < gridManagerArray.length; i++) {\r\n                // 绘制 Map 里面已有的 Tile\r\n                _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawMapTile(ctx, tileManager, gridManagerArray[i], space);\r\n            }\r\n        }\r\n        else {\r\n            // 绘制 Map 里面已有的 Tile\r\n            _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawMapTile(ctx, tileManager, gridManagerArray[layer], space);\r\n        }\r\n        RendererTools.drawStartAndEnd(ctx, space, gridManagerArray[0].getGrid(flag.start.x, flag.start.y).x, gridManagerArray[0].getGrid(flag.start.x, flag.start.y).y, gridManagerArray[0].getGrid(flag.end.x, flag.end.y).x, gridManagerArray[0].getGrid(flag.end.x, flag.end.y).y);\r\n        // 绘制阴影\r\n        _drawTools__WEBPACK_IMPORTED_MODULE_0__.DrawTools.drawDark(ctx, space, gridManagerArray[layer].getGrid(posX, posY).x, gridManagerArray[layer].getGrid(posX, posY).y);\r\n    };\r\n    return RendererTools;\r\n}());\r\n\r\n\n\n//# sourceURL=webpack://MapEditor/./src/ts/view/renderer.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ts/tileController.ts");
/******/ 	
/******/ })()
;